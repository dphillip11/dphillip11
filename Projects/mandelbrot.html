<!doctype html>
<html>

<head>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #f5f5f5;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #my_Canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #topContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            z-index: 1;
        }

        #banner {
            font-size: 24px;
        }

        #colorRange {
            width: 50%;
            height: 30px;
            background: #fff;
            border-radius: 5px;
            margin-right: 50px;
            ;
            outline: none;
        }

        #colorRange::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            border-radius: 5px;
            height: 25px;
            background: #4CAF50;
            cursor: pointer;
        }

        #colorRange::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 5px;
            background: #4CAF50;
            cursor: pointer;
        }

    </style>
</head>

<body>

    <div id="topContainer">
        <div id="banner">Mandelbrot Visualisation</div>
        <input type="range" id="colorRange" name="colorRange" min="0" max="100" step="1" value="32">

    </div>
    <canvas width="1920" height="1080" id="my_Canvas"></canvas>

    <button id="infoButton"
        style="color:yellow;background-color: rgba(246, 174, 17, 0.378);position: absolute;border-radius: 5px; top: 100px; left: 10px; z-index: 2;">?</button>

    <div id="infoModal"
        style=" position: fixed; z-index: 1; left: 100px; top: 100px; width: 400px; height: 0%; background-color: rgba(0,0,0,0.4);">
        <div style="background-color: rgba(217, 39, 39, 0.664); padding: 20px; border: 1px solid #888; width: 80%;">
            <span id="close"
                style="color: #aaaaaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer;">&times;</span>
            <p style="color: yellow; font-weight: bold;">Use the scroll wheel to zoom in and out.</p>
            <p style="color: yellow; font-weight: bold;">Use the arrow keys to move around.</p>
            <p style="color: yellow; font-weight: bold;">Use the slider at the top to change colors.</p>
        </div>
    </div>


    <script>

        /*============== Creating a canvas ====================*/
        var canvas = document.getElementById('my_Canvas');
        gl = canvas.getContext('webgl2');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        var scale = 0.5;
        var offset = { x: -0.5, y: 0.0 };

        var modal = document.getElementById("infoModal");
        var btn = document.getElementById("infoButton");
        var span = document.getElementById("close");

        btn.onclick = function () {
            if (modal.style.display === "none") {
                modal.style.display = "block";
            } else {
                modal.style.display = "none";
            }
        }

        span.onclick = function () {
            modal.style.display = "none";
        }

        window.onclick = function (event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }

        window.addEventListener('resize', function () {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            requestAnimationFrame(drawScene);
        });

        canvas.addEventListener('wheel', onWheel, false);

        function onWheel(event) {
            var delta = Math.sign(event.deltaY);
            if (delta > 0) {
                // zoom out
                scale *= 1.1;
            }
            else {
                // zoom in
                scale *= 0.9;
            }
            requestAnimationFrame(drawScene);
        }

        var speed = 0.5; // Change this value to control the speed of panning

        window.addEventListener('keydown', function (event) {
            modified_scale = scale;
            switch (event.key) {
                case 'ArrowUp':
                    offset.y += speed * modified_scale;
                    break;
                case 'ArrowDown':
                    offset.y -= speed * modified_scale;
                    break;
                case 'ArrowLeft':
                    offset.x -= speed * modified_scale;
                    break;
                case 'ArrowRight':
                    offset.x += speed * modified_scale;
                    break;
            }
            requestAnimationFrame(drawScene);
        }, false);

        var colorScheme = 0;

        document.getElementById("colorRange").addEventListener("input", function (event) {
            colorScheme = parseInt(event.target.value);
            requestAnimationFrame(drawScene);
        });

        colorScheme = parseInt(document.getElementById("colorRange").value);

        document.getElementById("colorRange").addEventListener("keydown", function (event) {
            if (event.key.startsWith("Arrow")) {
                event.preventDefault();
            }
        });



        /*======== Defining and storing the geometry ===========*/

        var vertices = [
            -1, 1, 0.0,
            -1, -1, 0.0,
            1, -1, 0.0,
            1, 1, 0.0
        ];

        indices = [0, 1, 2, 0, 2, 3];

        // Create an empty buffer object to store vertex buffer
        var vertex_buffer = gl.createBuffer();

        // Bind appropriate array buffer to it
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Pass the vertex data to the buffer
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        // Unbind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // Create an empty buffer object to store Index buffer
        var Index_Buffer = gl.createBuffer();

        // Bind appropriate array buffer to it
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

        // Pass the vertex data to the buffer
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // Unbind the buffer
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        /*================ Shaders ====================*/

        // Vertex shader source code
        var vertCode = '#version 300 es\n' +
            'in vec3 coordinates;' +

            'void main(void) {' +
            ' gl_Position = vec4(coordinates, 1.0);' +
            '}';

        // Create a vertex shader object
        var vertShader = gl.createShader(gl.VERTEX_SHADER);

        // Attach vertex shader source code
        gl.shaderSource(vertShader, vertCode);

        // Compile the vertex shader
        gl.compileShader(vertShader);
        if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
            console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertShader));
        }

        //fragment shader source code
        var fragCode = `#version 300 es
precision highp float;
out vec4 fragColor;
uniform float iTime;
uniform vec2 canvasSize;
uniform vec2 offset;
uniform float scale;
uniform float colorScheme;
float colors = 60.;   
const float max_iter = 500.0;
vec2 trapCenter1 = vec2(0.2, 0.3);
vec2 trapCenter2 = vec2(-0.5, 0.1);
float trapRadius1 = 0.1;
float trapRadius2 = 0.2;

vec3 trapColor[3] = vec3[](
    vec3(1., 0., 0.), // Red color for trap 1
    vec3(0., 1., 0.), // Green color for trap 2
    vec3(0., 0., 1.)  // Blue color for trap 3
);

vec3 computeTraps(vec2 z) {
    vec2 traps[3] = vec2[](
        vec2(0.2, 0.3), 
        vec2(-0.5, 0.1),
        vec2(sin(iTime), cos(iTime))
    );
    vec3 color = vec3(0.0);
    for(int i = 0; i < traps.length(); i++) {
        vec2 trap = traps[i];
        vec3 trapC = trapColor[i];
        float dist = length(z - trap);
        color += trapC / (1.0 + dist * dist); // color contribution based on the distance
    }
    return color;
}

vec3 colorize(float m, vec3 trapColor) {
    float offset_r = 0.1*colorScheme + 0.;
    float offset_g = 0.2*colorScheme + 3.14/6.; 
    float offset_b = 0.3*colorScheme + 3.14/3.;
    float increment = 3.1415 / (colors - 1.);
    float R = 125. * (sin((increment * m) + offset_r)+1.);
    float G = 125. * (sin((increment * m) + offset_b) +1.);
    float B = 125. * (sin((increment * m) + offset_g)+1.);
    vec3 color = vec3(R,G,B)/255.;

    // Blend the trap color with the calculated color
    return mix(color, trapColor, 0.5);
}

vec2 cmul(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }


float mandelbrot_perturbation( vec2 c, vec2 dc, out vec2 z_out )
{
    vec2 z  = vec2(0.0);
    vec2 dz = vec2(0.0);
    float n = -1.0;
    for( int i=0; i<6000; i++ )
    {
        dz = cmul(2.0*z+dz,dz) + dc; 
        z  = cmul(z,z)+c; 
        if( dot(dz,dz)>4.0 ) { 
            n = float(i);
            break;
        }
    }
    z_out = z;
    return n;
}

void main() {
    vec2 fragCoord = gl_FragCoord.xy / canvasSize.y;  // Normalize to [0, 1]
    vec2 p = fragCoord * 2.0 - 1.0;  // Convert to [-1, 1]
    p = p * scale + offset;  // Apply scale and offset

    vec2 c= vec2(-1.,0.);  

    vec2 dc = p;
    vec2 z;
    float m = mandelbrot_perturbation(c, dc, z);
    
    vec3 trapColor = computeTraps(z);
    vec3 color = colorize(m, trapColor);

    fragColor = vec4(color, 1.0);
}
`;





        // Create fragment shader object
        var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

        // Attach fragment shader source code
        gl.shaderSource(fragShader, fragCode);

        // Compile the fragmentt shader
        gl.compileShader(fragShader);
        if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
            console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragShader));
        }

        // Create a shader program object to store
        // the combined shader program
        var shaderProgram = gl.createProgram();

        // Attach a vertex shader
        gl.attachShader(shaderProgram, vertShader);

        // Attach a fragment shader
        gl.attachShader(shaderProgram, fragShader);

        // Link both the programs
        gl.linkProgram(shaderProgram);

        // Use the combined shader program object
        gl.useProgram(shaderProgram);

        /*======= Associating shaders to buffer objects =======*/

        // Bind vertex buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Bind index buffer object
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

        // Get the attribute location
        var coord = gl.getAttribLocation(shaderProgram, "coordinates");

        // Point an attribute to the currently bound VBO
        gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);

        // Enable the attribute
        gl.enableVertexAttribArray(coord);

        var offsetLocation = gl.getUniformLocation(shaderProgram, "offset");
        var scaleLocation = gl.getUniformLocation(shaderProgram, "scale");
        var colorSchemeLocation = gl.getUniformLocation(shaderProgram, "colorScheme");
        var canvasSizeLocation = gl.getUniformLocation(shaderProgram, "canvasSize");
        var timeLocation = gl.getUniformLocation(shaderProgram, "iTime");
        var processing = false;
        function drawScene() {

            gl.uniform1f(timeLocation, Date.now());
            gl.uniform2f(canvasSizeLocation, canvas.width, canvas.height);
            gl.uniform1f(scaleLocation, scale);
            gl.uniform2f(offsetLocation, offset.x, offset.y);
            gl.uniform1f(colorSchemeLocation, colorScheme);
            /*=========Drawing the triangle===========*/
            // Clear the canvas
            gl.clearColor(1, 0.5, 0.5, 0.9);

            // Enable the depth test
            gl.enable(gl.DEPTH_TEST);

            // Clear the color buffer bit
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Set the view port
            gl.viewport(0, 0, canvas.width, canvas.height);

            // Draw the triangle
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }


        requestAnimationFrame(drawScene);

        window.addEventListener('DOMContentLoaded', function () {
            requestAnimationFrame(drawScene);
        });

    </script>
</body>

</html>
