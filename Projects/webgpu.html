<!doctype html>
<html>

<body>
    <div>
        <label for="colorRange">Color scheme:</label>
        <input type="range" id="colorRange" name="colorRange" min="0" max="1" step="0.01" value="0">
    </div>
    <canvas width="1920" height="1080" id="my_Canvas"></canvas>
    <script>
        /*============== Creating a canvas ====================*/
        var canvas = document.getElementById('my_Canvas');
        var scale = 4.0;
        var center = { x: 0.0, y: 0.0 };
        var max_iter = 500.0;

        async function start() {
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const context = canvas.getContext('gpupresent');

            /*======== Defining and storing the geometry ===========*/

            var vertices = [
                -1, 1, 0.0,
                -1, -1, 0.0,
                1, -1, 0.0,
                1, 1, 0.0
            ];

            indices = [0, 1, 2, 0, 2, 3];

            // Create an empty buffer object to store vertex buffer
            var vertex_buffer = device.createBuffer({
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true,
            });
            new Float32Array(vertex_buffer.getMappedRange()).set(vertices);
            vertex_buffer.unmap();

            // Create an empty buffer object to store Index buffer
            var Index_Buffer = device.createBuffer({
                size: indices.byteLength,
                usage: GPUBufferUsage.INDEX,
                mappedAtCreation: true,
            });
            new Uint16Array(Index_Buffer.getMappedRange()).set(indices);
            Index_Buffer.unmap();

            /*================ Shaders ====================*/

            // Vertex shader source code
            var vertCode = `
                [[location(0)]] var<in> coordinates : vec3<f32>;

                [[builtin(position)]] var<out> Position : vec4<f32>;

                [[stage(vertex)]]
                fn main() -> void {
                    Position = vec4<f32>(coordinates, 1.0);
                    return;
                }
            `;

            // Fragment shader source code
            var fragCode = `
                [[binding(0), group(0)]] var colorScheme : f32;

                [[stage(fragment)]]
                fn main() -> [[location(0)]] vec4<f32> {

                    return vec4<f32>(1.0,0,0, 1.0);
                }

                fn colorize(m : f32, t : f32) -> vec3<f32> {
                    return vec3<f32>(
                        sin(0.016 * m + f32(t) + 4.0 + colorScheme),
                        sin(0.013 * m + f32(t) + 2.0 + colorScheme),
                        sin(0.01 * m + f32(t) + 1.0 + colorScheme)
                    );
                }
            `;

            // Create a shader module for the vertex and fragment shaders
            const vertModule = device.createShaderModule({
                code: vertCode,
            });

            const fragModule = device.createShaderModule({
                code: fragCode,
            });

            // Create a pipeline
            const pipeline = device.createRenderPipeline({
                vertex: {
                    module: vertModule,
                    entryPoint: 'main',
                    buffers: [{
                        arrayStride: 4 * 3, // sizeof(float) * 3
                        attributes: [{
                            // position
                            shaderLocation: 0,
                            offset: 0,
                            format: 'float32x3',
                        }],
                    }],
                },
                fragment: {
                    module: fragModule,
                    entryPoint: 'main',
                    targets: [{
                        format: 'bgra8unorm',
                    }],
                },
                primitive: {
                    topology: 'triangle-list',
                },
            });

            /*======= Associating shaders to buffer objects =======*/

            // Bind vertex buffer object
            const vertexBuffer = {
                buffer: vertex_buffer,
                offset: 0,
                size: vertices.byteLength,
            };

            // Bind index buffer object
            const indexBuffer = {
                buffer: Index_Buffer,
                offset: 0,
                size: indices.byteLength,
            };

            function drawScene() {
                const commandEncoder = device.createCommandEncoder();
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        loadValue: { r: 1, g: 0.5, b: 0.5, a: 0.9 },
                        storeOp: 'store',
                    }],
                });

                renderPass.setPipeline(pipeline);
                renderPass.setVertexBuffer(0, vertexBuffer.buffer);
                renderPass.setIndexBuffer(indexBuffer.buffer, 'uint16');
                renderPass.drawIndexed(indices.length, 1, 0, 0, 0);
                renderPass.endPass();

                device.queue.submit([commandEncoder.finish()]);
            }
            drawScene();
        }
        start();
    </script>
</body>

</html>
